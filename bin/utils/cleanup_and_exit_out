#!/bin/bash
#                         License
#
# Copyright (C) 2024  David Valin dvalin@redhat.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# Report and record any passed message and perform any of the following,
# depending on the passed arguments.
#
# 1) Delete the lock file
# 2) Restore a set of files.
# 3) Remove the cli_supplied options file.
#
# At the end we will exit out with the return code passed.  If no return
# code is passed, then a value of 0 is returned by default.
#
# Note this script should be called via exec, that way when we exit, we will exit
# back to the shell, not the calling program.
#


cle_usage()
{
	echo "Usage: $0"
	echo "--cli_supplied_options <file>, file containing cli options to be removed."
	echo "--fail_report <file>: File to report failures in. Default: failed_test."
	echo "--msg_string <string>: Message to output."
	echo "--pid <pid>: Pid of the process that holds any locks."
	echo "--restore_file <copy,original>: Restores a file from a copy.  You may"
	echo "  designate multile --restor_file"
	echo "--rtc <rtc>: Return code. Default is 0"
	echo "--sysname <sysname>: Name of system."
	echo "--top_dir <dir>: Execution top level directory.  Default is current directory"
	echo "--usage: this usage message"
	echo "-h: this usage message"
	exit 0
}

cleanup_and_exit_out()
{
	cli_supplied_options=""
	msg_string=""
	rtc="0"
	sysname=""
	restore_file=""
	separ=""
	top_dir=`pwd`
	pid=""
	fail_report="failed_test"

	ARGUMENT_LIST=(
		"cli_supplied_options"
		"fail_report"
		"msg_string"
		"pid"
		"restore_file"
		"rtc"
		"sysname"
		"top_dir"
	)

	NO_ARGUMENTS=(
		"usage"
	)

	# read arguments
	opts=$(getopt \
		--longoptions "$(printf "%s:," "${ARGUMENT_LIST[@]}")" \
		--longoptions "$(printf "%s," "${NO_ARGUMENTS[@]}")" \
		--name "$(basename "$0")" \
		--options "h" \
		-- "$@"
	)

	eval set --$opts
	if [[ $? -ne 0 ]]; then
		cle_usage $0
	fi

	while [[ $# -gt 0 ]]; do
		case "$1" in
			--cli_supplied_options)
				cli_supplied_options=$2
				shift 2
			;;
			--fail_report)
				fail_report=$2
				shift 2
			;;
			--msg_string)
				msg_string=$2
				shift 2
			;;
			--pid)
				pid=$2
				shift 2
			;;
			--restore_file)
				restore_file=${restore_file}${separ}$2
				separ=" "
				shift 2
			;;
			--rtc)
				rtc=$2
				shift 2
			;;
			--sysname)
				sysname=$2
				shift 2
			;;
			--top_dir)
				top_dir=$2
				shift 2
			;;
			--usage)
				cle_usage $0
			;;
			--h)
				cle_usage $0
			;;
			--)
				break;
			;;
			*)
				echo "option not found ${1}"
				cle_usage $0
			;;
		esac
	done
	if [[ $UTILS_DIR == "" ]]; then
		UTILS_DIR=`echo $0 | rev | cut -d'/' -f2- | rev`
	fi

	if [[ $pid != "" ]]; then
		$UTILS_DIR/cleanup_install_lock $pid
	fi
	if [[ $cli_supplied_options != "" ]]; then
		rm $cli_supplied_options 2> /dev/null
	fi
	if [[ $rtc != "0" ]] && [[ $msg_string != "" ]]; then
		if [[ $sysname == "" ]]; then
			sysname=`uname -n`
		fi
		timestamp=`date`
		if [[ ${sysname} != "" ]]; then
			error_string="${timestamp} ${sysname}, $msg_string"
		else
			error_string="${timestamp} $msg_string"
		fi
		echo -e "${error_string}"
		#
		# Use flock so we do not have multiple procs at the same time writing
		# to the file.
		#
		flock -x $top_dir/$fail_report echo -e "${error_string}" >> $top_dir/$fail_report
	else
		if [[ $msg_string != "" ]]; then
			echo $msg_string
		fi
	fi
	#
	# Restore the requested files.
	#
	if [[ $restore_file != "" ]]; then
		for pair in $restore_file; do
			from=`echo $pair | cut -d',' -f 1`
			to=`echo $pair | cut -d',' -f 2`
			rm  -f $to
			mv $from $to
		done
	fi
	exit $rtc
}

if [ $# -ne 0 ]; then
	cleanup_and_exit_out "$@"
fi
