#!/bin/bash
#
# Takes the config string from burden and generate something that bash canuse easier.
#
# Input format
# <system>:<config> 
#     Note <config> can be more one field grouping, each grouping is separated by '&'
# Output format:
#  <system>:<disk size>:<disk type>:<number disks>
#
# Input example
#  m5.xlarge:Disks;number=2;size=6000;type=gp2
# Output example
#  m5.xlarge:6000:gp2:2
#
dfield=""
disk_size=100
disk_type=gp2
disk_iops="none"
disk_tp="none"
number_disks=0
set_disk_field()
{
	value=`echo ${dfield} | cut -d'=' -f 2`
	if [[ $dfield == *"number"* ]]; then
		number_disks=$value
	elif [[ $dfield == *"type"* ]]; then
		disk_type=$value
	elif [[ $dfield == *"size"* ]]; then
		disk_size=$value
	elif [[ $dfield == *"iops"* ]]; then
		disk_iops=$value
	elif [[ $dfield == *"throughput"* ]]; then
		disk_tp=$value
	else
		echo $dfield: Unknown field, bail out.
		exit 1
	fi
}

#
# The argument being pased in will have an '&' as a separator field.  To allow bash to work
# with the string, we will replace it with a ' '
#
instance_type=`echo $1 | cut -d: -f1`
fields=`echo "$1" | sed "s/&/ /g"`
index=0
for i in $fields
do
	let "index=$index+1"
	if [[ $i == *"Disks"* ]]; then
		ct_config=$i
		break
	fi
done

lookup=0
if [[ $ct_config == *"Disks"* ]]; then
	let "index=$index+1"
	field=`echo $ct_config | cut -d: -f${index}`
	dindex=1
	dfield=`echo $ct_config | cut -d';' -f${dindex}`
	while [ $dfield != "" ]; do
		if [[ $lookup -eq 1 ]]; then
			set_disk_field
		fi
		if [[ $dfield == *"Disk"* ]]; then
			lookup=1
		fi
		let "dindex=$dindex+1"
		new_dfield=`echo $ct_config | cut -d';' -f${dindex}`
		if [[ -z $new_dfield ]] ; then
			break
		fi
		if [[ $new_dfield == $dfield ]]; then
			break
		fi
		dfield=$new_dfield
	done
else
	instance_type=$ct_config
fi
echo $instance_type:$disk_size:$disk_type:$number_disks:$disk_iops:${disk_tp}
exit 0
